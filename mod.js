// Copyright 2020 Dennis Lien. All rights reserved. MIT license.

const { args, env} = Deno;
import { parse } from 'https://deno.land/std@0.51.0/flags/mod.ts';
import { ensureDir, readFileStr, writeFileStr, walk, exists } from "https://deno.land/std@0.51.0/fs/mod.ts";
import * as logger from 'https://deno.land/std/log/mod.ts';

const inputArgs = parse(args);

const tempTemplate = `#!/bin/sh
# generated by bs 'create script' 
`;

const bashProfilePath = `${env.get('HOME')}/.bash_profile`;

const bsHome = `${env.get('HOME')}/.bs`;

const bsBin = `${bsHome}/bin`;
const bsBinGlobals = `${bsBin}/global`;
const bsBinProjects = `${bsBin}/project`;
const bsBinProject = (projectName) => `${bsBinProjects}/${projectName}`;

const bsAlias = `${bsHome}/alias`;
const bsAliasGlobals = `${bsAlias}/global`;
const bsAliasProjects = `${bsAlias}/project`;
const bsAliasProject = (projectName) => `${bsAliasProjects}/${projectName}`;

const bsAliasMain = (aliasDir) => `${aliasDir}/main.sh`;

const createAliasFilePath = (dir, name) => `${dir}/${name}.sh`
const createAliasStr = (name, command) => `alias ${name}="${command}"`

const toSourceString = (filePath) => `source ${filePath}`;

async function ensureBs() {
  await ensureDir(bsBinGlobals);
  await ensureDir(bsBinProjects);
  await ensureDir(bsAliasGlobals);
  await ensureDir(bsAliasProjects);
  return true;
}


async function upsertFolderMain(aliasDir) {
  const aliases = [];
  const mainPath = bsAliasMain(aliasDir);
  for await (const entry of walk(aliasDir)) {
    if (entry && entry.isFile && entry.name !== 'main.sh') {
      const alias = await readFileStr(`${aliasDir}/${entry.name}`, { encoding: 'utf8' });
      aliases.push(alias);
    }
  }
  await writeFileStr(mainPath, aliases.join('\n'));
  return mainPath;
}

async function getFileNames(dir, includeMain) {
  const fileNames = [];
  for await (const entry of walk(dir)) {
    if (entry.isFile && (!includeMain && !entry.name.includes('main.sh'))) {
      fileNames.push(entry.name);
    }
  }
  return fileNames;
}

async function updateBashProfile(source) {
  const org = await readFileStr(bashProfilePath, { encoding: 'utf8' });
  if (org.includes(source)) {
    return true;
  }
  return writeFileStr(bashProfilePath, `${org}\n${source}\n`);
}

async function createAliasFile(dir, name, command) {
  const filePath = createAliasFilePath(dir, name);
  const aliasString = createAliasStr(name, command);

  await writeFileStr(filePath, aliasString);
  return {
    filePath,
    aliasString,
  };
}

async function getProjectDir(projectPathFn) {
  const getGitRemote = Deno.run({
    cmd: ['git', 'remote', '-v'],
    stdout: "piped",
    stderr: "piped",
  });
  const { code } = await getGitRemote.status();
  if (code === 0) {
    const rawOutput = await getGitRemote.output();
    const gitRemoteString = new TextDecoder().decode(rawOutput);
    // TODO: regEx
    const projectName = gitRemoteString.split('\n')[0]
      .replace('origin\t', '')
      .replace('(fetch)', '')
      .replace(' ', '')
      .replace('.git', '');

    const projectPath = projectPathFn(projectName);
    await ensureDir(projectPath);
    return projectPath;
  } else {
    const errorString = new TextDecoder().decode(rawError);
    logger.error(errorString);
    throw new Error('Unable to get the git remote Origin');
  }
}

const commands = {
  create: {
    alias: {
      exec: async (flags) => {
        const isGlobal = (flags.g || flags.global);
        const originalCommand = flags.org || flags.o;
        const name = flags.name || flags.n;
        const aliasDir = isGlobal ? bsAliasGlobals : await getProjectDir(bsAliasProject);

        if (!name || !originalCommand) {
          // TODO: return help
          return logger.error(
            'Name (--name, -n) and "original command" (--org, -o) is required',
          );
        }

        await ensureBs();

        const { aliasPath, aliasString } = await createAliasFile(aliasDir, name, originalCommand);
        const aliasMainPath = await upsertFolderMain(aliasDir)
        const sourceString = toSourceString(aliasMainPath);

        if (isGlobal) {
          await updateBashProfile(sourceString);
          // TODO: this returns 404 not found... why?
          // const sourceFile = Deno.run({
          //   cmd: ['source', aliasMainPath],
          // });
          return console.log(toSourceString(bashProfilePath));
        }

        return console.log(sourceString);
      },
      help: (flags) => {
        logger.info('TODO: add help')
      },
    },
    project: {
      exec: async (flags) => {
        const projectPath = await getProjectDir(bsBinProject);
        return logger.info(`Project folder at: ${projectPath}`);
      },
    },
    script: {
      exec: async (flags) => {
        const name = flags.name || flags.n;
        if (!name) {
          return logger.error('Name (--name, -n), is required');
        }
        const projectPath = await getProjectDir(bsBinProject);
        const filePath = `${projectPath}/${name}.sh`;
        return writeFileStr(filePath, tempTemplate);
      },
    },
  },
  load: {
    alias: {
      exec: async (flags) => {
        const isGlobal = (flags.g || flags.global);
        const aliasDir = isGlobal ? bsAliasGlobals : await getProjectDir(bsAliasProject);
        const mainPath = bsAliasMain(aliasDir);
        if (isGlobal) {
          return console.log(toSourceString(bashProfilePath));
        }
        return console.log(toSourceString(mainPath)); 
      },
    }
  },
  open: {
    project: {
      exec: async (flags) => {
        const projectPath = await getProjectDir(bsBinProject);
        const openInCode = Deno.run({
          cmd: ['code', projectPath],
        });
        await openInCode.status();
        return logger.info(`Project folder at: ${projectPath}`);
      },
    },
  },
  ls: {
    exec: async (flags) => {
      const aliasesFileNames = [];
      const scriptsFileNames = [];
      const result = {};

      const alias = flags.a || flags.alias;
      const isGlobal = flags.g || flags.global;
      const scripts = flags.s || flags.script;

      const aliasDir = isGlobal ? bsAliasGlobals : await getProjectDir(bsAliasProject);
      const scriptDir = isGlobal ? bsBinGlobals : await getProjectDir(bsBinProject);

      const getScriptsAndAliases = (!alias && !scripts);
      if (getScriptsAndAliases || scripts) {
        const scriptsNames = await getFileNames(scriptDir, false);
        scriptsFileNames.push(...scriptsNames);
        Object.assign(result, {
          scripts: scriptsFileNames,
        });
      }
      if (getScriptsAndAliases || alias) {
        // Map to remove the file type, user do not need to know, they are exec with out.
        const aliasesNames = (await getFileNames(aliasDir, false)).map((item) => item.split('.')[0]);
        aliasesFileNames.push(...aliasesNames);
        Object.assign(result, {
          aliases: aliasesFileNames,
        });
      }
      
      return console.log(JSON.stringify(result, null, 2))
    },
  },
  r: {
    exec: async (params, flags) => {
      const projectPath = await getProjectDir(bsBinProject);
      const filePath = `${projectPath}/${params[0]}`;
      const doesExist = await exists(filePath);

      if (!doesExist) {
        return logger.error(`Script: ${params[0]} does not exist in: ${projectPath}`);
      }

      const runScript = Deno.run({
        cmd: ['bash', filePath],
        stdout: "piped",
        stderr: "piped",
      });
      const { code } = await runScript.status();
      if (code === 0) {
        const rawOutput = await runScript.output();
        const result = new TextDecoder().decode(rawOutput);
        return console.info(result);
      } else {
        const rawError = await runScript.stderrOutput();
        const errorString = new TextDecoder().decode(rawError);
        logger.error(errorString);
        throw new Error('Unable to run script, error above.');
      }

    },
  },
};

function runner(input) {
  const { _, ...rest } = input;
  if (_[0] === 'r' || _[0] === 'run') {
    const params = [..._].slice(1);
    return commands.r.exec(params, rest);
  }
  const func = _.reduce((result, name) => {
   if (!result[name]) {
     // TODO: return help
     throw new Error('Not a command');
   } 
   return result[name];
  }, commands)
  if (typeof func.exec !== 'function') {
    // TODO: return help
    return logger.info('Missing props');
  }
  return func.exec(rest);
}

runner(inputArgs);